# Model Instance Configuration (process configuration file)

**Prerequisite** Please review the [Learning Modules](../../README.md#learning-modules). This readme assumes that the audience is familiar with the high-level concepts which comprise the process config.

In addition to a language and primitives for configuring an abstract process model, the Open Process Library project provides a YAML configuration syntax for mapping concrete assets to the abstract model in a lightweight way. The intent of providing this syntax is to make "manual" onboarding faster and easier (because the resulting data file is machine-readable and can be machine-validated) as well as provide a clean interface format for machine-assisted onboarding to use.

NB: Some of the instructions here detail specific elements of implementation (such as references to CloudIoT registration). These should be relatively obvious to a critical reader, but if they are confusing, feel free to post an issue in the project.

*   For an explanation of types in the Open Process Library abstract model see [model](model.md)
*   For a conceptual explanation of the ontology see [ontology](ontology.md)

- [Model Instance Configuration](#model-instance-configuration)
  * [Key Concepts](#key-concepts)
  * [Typical Data Elements](#typical-data-elements)
  * [Configuration Detail](#configuration-detail)
    + [Contents](#contents)
    + [Config Format](#config-format)
    + [Spaces](#spaces)
    + [Devices](#devices)
      - [Reporting Physical Devices](#reporting-physical-devices)
        * [Defining Translations](#defining-translations)
          + [Translation Shortcuts](#translation-shortcuts)
      - [Virtual Devices](#virtual-devices)
      - [Device Relationships](#device-relationships)
    + [Zones and Control Groups](#zones-and-control-groups)
  * [Process Configuration Modes](#process-configuration-modes)
    + [INITIALIZE](#initialize)
    + [UPDATE](#update)
      - [General](#general-updates)
      - [Special Cases](#special-cases)
  * [Validation](#validation)
  * [Notes](#notes)

## Key Concepts

Creation of a concrete model is primarily concerned with defining entities, their relationships to each other, and their relationships to real physical things in the world.

Conceptually, we divide entities into three categories:

*   **Logical Entity**: An entity that maps 1:1 with a canonical concept in the model. For example, you might have an idealized concept of a Pump, with a corresponding entity type, that you may use for analysis. A logical pump would use this type or a child of it.
*   **Reporting Entity**: A reporting entity is one that generates telemetry data. Reporting entities are important to differentiate because they may have translations to convert their native data payload to a standard form.
*   **Virtual Entity**: A virtual entity does NOT directly generate telemetry data, but may still have a timeseries that is generated by linking data from other sources.

The following statements apply when considering entity categories:

*   Either a Reporting Entity or a Virtual Entity may be a Logical Entity.
*   Virtual Entities are typically also Logical Entities.
*   By convention, anything that receives telemetry is a Reporting Entity, even if it has data linked from other entities. In practice, however, we do not recommend mixing the two concepts (i.e. by linking additional data from other devices into a reporting device).

To completely map real data to the model we also need a few more concepts:

*   **Translation**: A key-value mapping between fields in a reporting device's payload and the standard fields in the device's assigned entity type.
*   **Link**: A mapping between a standard field in one device and another standard field in another device. Links map data from reporting devices to virtual devices.
*   **Connection**: Describes a relationship between two entities. See [Connections](ontology_config.md#connections)

These should all be defined in a complete configuration.

## Typical Data Elements

While there is basically infinite diversity in what can be defined for a process, some elements are more or less expected in every model:

*   All the logical spaces in the process with their unique names (Plant, Units, Sections).
*   Each logical piece of equipment (hereafter "device") and its associated Open Process Library Type.
*   Each reporting device registered in Cloud IoT (or your endpoint of choice, if not working on a specific infrastructure).
*   Link mappings between the points of reporting devices and logical devices, if the two are not the same.
*   Translation mappings between device-native point names and the standard point names for each reporting device.
*   Zones or Control Groups, as applicable.
*   `FEEDS` relationships between chained equipment in hydraulic or power systems, as well as between terminal units and Zones.
*   `CONTROLS` relationships between control groups and devices, and between controllers and control groups.
*   `CONTAINS` relationships between Zones or Control Groups and units.
*   `CONTAINS` relationships between all entities and sections (or more specific space, if known).
*   `CONTAINS` relationships between Plants and sections, and sections and units.

## Configuration Detail

### Contents

Each configuration file should contain the contents for one process (or other logical division of your universe). The reason for this is that the definitions in the file are intentionally not keyed by a globally unique identifier. This is done for a few reasons:

1.  The human-readable entity code is, well, more human-readable.
2.  Using human-readable codes, which are typically created at design time and known a-priori, allows for incremental population of the file at different stages of the commissioning or onboarding process, rather than having to wait until all the devices are cloud-registered.
3.  There is inherent value to forcing locally unique naming of spaces and equipment (because it makes it easier to find stuff).

### Config Format

The configuration format is focused around defining the entities in the model. A generic entity with all possible top-level fields looks like this[^5]:

**NOTE:** The new Process Config format switches entities being keyed by codes to being keyed by GUIDs and Ids are removed. To convert the old format to the new format, run your config.yaml through the [guid generator](https://github.com/google/digitalbuildings/tree/master/tools/guid_generator).

#### New Format
```yaml
f7d82b75-ea41-49e2-bb5a-53228044eb4c # Entity keyed by a GUID
  type: NAMESPACE/A_OPEN_PROCESS_LIBRARY_ENTITY_TYPE
  code: ENTITY-CODE
  connections:
    # Listed entities are sources on connections
    ANOTHER-ENTITY-GUID: FEEDS
    A-THIRD-ENTITY-GUID: CONTAINS
  links:
    A-FOURTH-ENTITY-GUID: # Source entity keyed by a GUID
      # target_device_field: source_device_field
      supply_pressure: supply_pressure_sensor_1
      flow_rate: flow_rate_sensor_1
  pol_device_id: device-id-from-cloud-iot-registry
  translation:
    flow_rate_sensor:
      present_value: "points.flow_rate_1.present_value"
      units:
        key: "pointset.points.flow_rate_1.units"
        values:
          liters_per_minute: "LPM"
    valve_position_command:
      present_value: "points.valve_1.present_value"
      states:
        OPEN: "1"
        CLOSED:
        - "2"
        - "3"
```

*   **GUID:** A globally unique identifier for the entity. This field does not need to be included initially and can be generated with guid generator.
*   **Type:** A valid, fully qualified Open Process Library entity type that represents this entity.
*   **Code:** The human-readable identifier for the entity. This should be unique in document scope.
*   **pol_device_id:** the numeric device id from cloud IoT registry. This field is mandatory when a translation exists. Must be a numeric string.
*   **Connections:** Used to specify connections from other entities (sources) pointing to this entity, with connection types. Entities are keys and cannot be repeated. Values are one or more connections, specified as a single value or a set.
*   **Links:** Used to specify mappings between standard fields of source entities to standard fields of this entity. First level key is another entity in the file (source). Second level key is a standard field of this (target) entity followed by a `:` and a standard field of the other (source) entity.
*   **Translation:** Used to specify how the fields of the device's native payload map to the standard fields of this entity's type. See [translation section](#defining-translations) for more detail.

### Spaces

In nearly every model, entities should exist for Plants, Units, and Sections. The following example shows a plant with one unit and one section:

```yaml
# Plant
A-PLANT-CODE:
  type: FACILITIES/PLANT

# Unit
A-PLANT-CODE-UNIT1:
  type: FACILITIES/UNIT
  connections:
    A-PLANT-CODE: CONTAINS

# Section
A-PLANT-CODE-UNIT1-SECTION123:
  type: FACILITIES/SECTION
  connections:
    A-PLANT-CODE-UNIT1: CONTAINS
```

*   Plants shall have `CONTAINS` connections to Units.
*   Units should have `CONTAINS` connections to all Sections.
*   Units should have `CONTAINS` connections to all Devices.

In this example, entities are identified by their globally unique identifiers. GUIDs are widely used and highly recommended due to their exponentially low collision rate.

Types for spaces are contained in the `FACILITIES